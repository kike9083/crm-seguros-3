-- =============================================
-- 1. CONFIGURACIÓN INICIAL Y TIPOS (ENUMS)
-- =============================================

-- Habilitar extensión UUID si no está habilitada
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Crear tipos ENUM (Manejamos excepciones por si ya existen)
DO $$ BEGIN
    CREATE TYPE user_role AS ENUM ('ADMIN', 'AGENTE');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
    CREATE TYPE lead_status AS ENUM ('PROSPECTO', 'V1', 'V2', 'V3', 'NO INTERESADO', 'GANADO', 'NUEVO', 'CONTACTADO', 'CALIFICADO', 'PERDIDO');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
    CREATE TYPE task_status AS ENUM ('PENDIENTE', 'EN PROGRESO', 'COMPLETADA');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
    CREATE TYPE policy_status AS ENUM ('ACTIVA', 'PENDIENTE PAGO', 'CANCELADA', 'VENCIDA');
EXCEPTION WHEN duplicate_object THEN null; END $$;


-- =============================================
-- 2. CREACIÓN DE TABLAS
-- =============================================

-- Tabla de Perfiles (Usuarios)
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    nombre TEXT,
    rol user_role DEFAULT 'AGENTE',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla de Leads
CREATE TABLE IF NOT EXISTS leads (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    nombre TEXT NOT NULL,
    email TEXT,
    telefono1 TEXT,
    telefono2 TEXT,
    fuente TEXT,
    estatus_lead lead_status DEFAULT 'PROSPECTO',
    notas TEXT,
    agent_id UUID REFERENCES auth.users(id),
    user_id UUID REFERENCES auth.users(id), -- Creador del registro
    fecha_nacimiento DATE,
    ocupacion TEXT,
    ingresos_mensuales NUMERIC,
    polizas_externas TEXT,
    cedula TEXT,
    empresa TEXT
);

-- Tabla de Clientes
CREATE TABLE IF NOT EXISTS clients (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    nombre TEXT NOT NULL,
    email TEXT,
    telefono1 TEXT,
    telefono2 TEXT,
    fecha_nacimiento DATE,
    lead_origen_id BIGINT REFERENCES leads(id) UNIQUE,
    agent_id UUID REFERENCES auth.users(id),
    user_id UUID REFERENCES auth.users(id),
    ocupacion TEXT,
    ingresos_mensuales NUMERIC,
    polizas_externas TEXT,
    cedula TEXT,
    empresa TEXT
);

-- Tabla de Productos
CREATE TABLE IF NOT EXISTS products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    nombre TEXT NOT NULL,
    aseguradora TEXT DEFAULT 'PALIG',
    comision_porcentaje NUMERIC DEFAULT 0,
    prima_mensual NUMERIC DEFAULT 0,
    suma_asegurada NUMERIC DEFAULT 0,
    activo BOOLEAN DEFAULT TRUE,
    categoria TEXT,
    descripcion TEXT
);

-- Tabla de Pólizas
CREATE TABLE IF NOT EXISTS policies (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    client_id BIGINT REFERENCES clients(id),
    product_id BIGINT REFERENCES products(id), -- Legacy support
    productos_detalle JSONB DEFAULT '[]'::jsonb, -- Nuevo soporte multiproducto
    prima_total NUMERIC DEFAULT 0, -- Prima Mensual Total
    prima_mensual_total NUMERIC DEFAULT 0, -- Redundancia explicita
    suma_asegurada_total NUMERIC DEFAULT 0,
    fecha_emision DATE,
    fecha_vencimiento DATE,
    estatus_poliza policy_status DEFAULT 'ACTIVA',
    comision_agente NUMERIC DEFAULT 0, -- Comisión Mensual Total
    agent_id UUID REFERENCES auth.users(id),
    user_id UUID REFERENCES auth.users(id)
);

-- Tabla de Tareas
CREATE TABLE IF NOT EXISTS tasks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    lead_id BIGINT REFERENCES leads(id),
    client_id BIGINT REFERENCES clients(id),
    tipo TEXT, -- 'LLAMADA', 'EMAIL', etc.
    fecha_vencimiento DATE,
    prioridad TEXT, -- 'ALTA', 'MEDIA', 'BAJA'
    descripcion TEXT,
    estatus task_status DEFAULT 'PENDIENTE',
    agent_id UUID REFERENCES auth.users(id),
    user_id UUID REFERENCES auth.users(id)
);

-- Tabla de Metas Mensuales
CREATE TABLE IF NOT EXISTS monthly_goals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    month INT NOT NULL,
    year INT NOT NULL,
    vida NUMERIC DEFAULT 0,
    ap NUMERIC DEFAULT 0,
    salud NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, month, year)
);

-- Tabla de Auditoría
CREATE TABLE IF NOT EXISTS audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    action TEXT NOT NULL, -- 'CREATE', 'UPDATE', 'DELETE', 'IMPORT'
    entity TEXT NOT NULL, -- 'LEAD', 'CLIENT', 'POLICY', 'TASK'
    entity_id TEXT,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);


-- =============================================
-- 3. SEGURIDAD (ROW LEVEL SECURITY - RLS)
-- =============================================

-- Habilitar RLS en todas las tablas
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE policies ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE monthly_goals ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Limpieza de políticas antiguas para evitar conflictos al desplegar
DO $$ 
DECLARE 
  r RECORD; 
BEGIN 
  FOR r IN SELECT tablename, policyname FROM pg_policies LOOP 
    EXECUTE format('DROP POLICY IF EXISTS "%s" ON %I', r.policyname, r.tablename); 
  END LOOP; 
END $$;

-- Políticas PROFILES
CREATE POLICY "Profiles_Read_All" ON profiles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Profiles_Insert_Self" ON profiles FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "Profiles_Update_Self_Or_Admin" ON profiles FOR UPDATE TO authenticated USING (auth.uid() = id OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas LEADS
CREATE POLICY "Leads_Select" ON leads FOR SELECT TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Leads_Insert" ON leads FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Leads_Update" ON leads FOR UPDATE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Leads_Delete" ON leads FOR DELETE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas CLIENTS
CREATE POLICY "Clients_Select" ON clients FOR SELECT TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Clients_Insert" ON clients FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Clients_Update" ON clients FOR UPDATE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Clients_Delete" ON clients FOR DELETE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas POLICIES
CREATE POLICY "Policies_Select" ON policies FOR SELECT TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Policies_Insert" ON policies FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Policies_Update" ON policies FOR UPDATE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Policies_Delete" ON policies FOR DELETE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas PRODUCTS (Todos leen, solo Admin edita)
CREATE POLICY "Products_Select" ON products FOR SELECT TO authenticated USING (true);
CREATE POLICY "Products_Modify" ON products FOR ALL TO authenticated USING ((SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas TASKS
CREATE POLICY "Tasks_Select" ON tasks FOR SELECT TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Tasks_Insert" ON tasks FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Tasks_Update" ON tasks FOR UPDATE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Tasks_Delete" ON tasks FOR DELETE TO authenticated USING (agent_id = auth.uid() OR user_id = auth.uid() OR (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');

-- Políticas AUDIT LOGS (Todos insertan, solo Admin lee)
CREATE POLICY "Audit_Select_Admin" ON audit_logs FOR SELECT TO authenticated USING ((SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN');
CREATE POLICY "Audit_Insert_All" ON audit_logs FOR INSERT TO authenticated WITH CHECK (true);


-- =============================================
-- 4. FUNCIONES ALMACENADAS (RPC)
-- =============================================

-- AUDITORÍA
CREATE OR REPLACE FUNCTION log_activity(p_action text, p_entity text, p_entity_id text DEFAULT null, p_details jsonb DEFAULT null)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    INSERT INTO audit_logs (user_id, action, entity, entity_id, details) VALUES (auth.uid(), p_action, p_entity, p_entity_id, p_details);
END;
$$;

-- USUARIOS
CREATE OR REPLACE FUNCTION create_new_user(email text, password text, nombre text, rol user_role)
RETURNS uuid LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  new_user_id uuid;
BEGIN
  -- Nota: Esta función requiere permisos especiales en Supabase o ejecutarse via Service Role si se usa en producción para crear usuarios auth
  -- Aquí simulamos la inserción en profiles, pero la creación auth debe ser manejada por la API de Supabase Auth.
  -- En un entorno real, esto suele dispararse por un Trigger on auth.users.
  RETURN null; 
END;
$$;

CREATE OR REPLACE FUNCTION get_all_profiles_for_admin()
RETURNS SETOF profiles LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM profiles; -- La política RLS filtra si no es admin, pero aquí forzamos lectura si es necesario, o confiamos en RLS.
$$;

-- LEADS
CREATE OR REPLACE FUNCTION get_leads_for_user()
RETURNS SETOF leads LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM leads WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() OR user_id = auth.uid() ORDER BY created_at DESC;
$$;

CREATE OR REPLACE FUNCTION create_lead_secure(
    p_nombre text, p_email text, p_telefono1 text, p_fuente text, p_estatus_lead text, p_notas text,
    p_agent_id uuid DEFAULT null, p_fecha_nacimiento date DEFAULT null, p_ocupacion text DEFAULT null,
    p_ingresos_mensuales numeric DEFAULT null, p_polizas_externas text DEFAULT null, p_telefono2 text DEFAULT null,
    p_cedula text DEFAULT null, p_empresa text DEFAULT null
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_lead_id bigint;
BEGIN
    INSERT INTO leads (nombre, email, telefono1, telefono2, fuente, estatus_lead, notas, agent_id, user_id, fecha_nacimiento, ocupacion, ingresos_mensuales, polizas_externas, cedula, empresa)
    VALUES (p_nombre, p_email, p_telefono1, p_telefono2, p_fuente, p_estatus_lead::lead_status, p_notas, p_agent_id, auth.uid(), p_fecha_nacimiento, p_ocupacion, p_ingresos_mensuales, p_polizas_externas, p_cedula, p_empresa)
    RETURNING id INTO v_lead_id;
    RETURN (SELECT row_to_json(l) FROM leads l WHERE id = v_lead_id);
END;
$$;

CREATE OR REPLACE FUNCTION update_lead_secure(
    p_id bigint, p_nombre text, p_email text, p_telefono1 text, p_fuente text, p_estatus_lead text, p_notas text,
    p_agent_id uuid DEFAULT null, p_fecha_nacimiento date DEFAULT null, p_ocupacion text DEFAULT null,
    p_ingresos_mensuales numeric DEFAULT null, p_polizas_externas text DEFAULT null, p_telefono2 text DEFAULT null,
    p_cedula text DEFAULT null, p_empresa text DEFAULT null
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_lead_id bigint;
BEGIN
    UPDATE leads SET nombre = p_nombre, email = p_email, telefono1 = p_telefono1, telefono2 = p_telefono2, fuente = p_fuente, estatus_lead = p_estatus_lead::lead_status, notas = p_notas, agent_id = p_agent_id, fecha_nacimiento = p_fecha_nacimiento, ocupacion = p_ocupacion, ingresos_mensuales = p_ingresos_mensuales, polizas_externas = p_polizas_externas, cedula = p_cedula, empresa = p_empresa, updated_at = NOW()
    WHERE id = p_id RETURNING id INTO v_lead_id;
    RETURN (SELECT row_to_json(l) FROM leads l WHERE id = v_lead_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_lead_secure(p_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    DELETE FROM leads WHERE id = p_id;
END;
$$;

CREATE OR REPLACE FUNCTION promote_lead_to_client(p_lead_id bigint)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_lead record; v_existing_client_id bigint; v_new_client_id bigint;
BEGIN
    SELECT id INTO v_existing_client_id FROM clients WHERE lead_origen_id = p_lead_id;
    IF v_existing_client_id IS NOT NULL THEN RETURN (SELECT row_to_json(c) FROM clients c WHERE id = v_existing_client_id); END IF;

    SELECT * INTO v_lead FROM leads WHERE id = p_lead_id;
    IF v_lead.email IS NOT NULL AND v_lead.email <> '' THEN
        SELECT id INTO v_existing_client_id FROM clients WHERE email = v_lead.email;
        IF v_existing_client_id IS NOT NULL THEN RETURN (SELECT row_to_json(c) FROM clients c WHERE id = v_existing_client_id); END IF;
    END IF;

    INSERT INTO clients (nombre, email, telefono1, telefono2, lead_origen_id, agent_id, user_id, created_at, updated_at, fecha_nacimiento, ocupacion, ingresos_mensuales, polizas_externas, cedula, empresa)
    VALUES (v_lead.nombre, v_lead.email, v_lead.telefono1, v_lead.telefono2, v_lead.id, v_lead.agent_id, auth.uid(), NOW(), NOW(), v_lead.fecha_nacimiento, v_lead.ocupacion, v_lead.ingresos_mensuales, v_lead.polizas_externas, v_lead.cedula, v_lead.empresa)
    RETURNING id INTO v_new_client_id;
    RETURN (SELECT row_to_json(c) FROM clients c WHERE id = v_new_client_id);
END;
$$;

-- CLIENTS
CREATE OR REPLACE FUNCTION get_clients_for_user()
RETURNS SETOF clients LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM clients WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() OR user_id = auth.uid() ORDER BY created_at DESC;
$$;

CREATE OR REPLACE FUNCTION update_client_secure(
    p_id bigint, p_nombre text, p_email text, p_telefono1 text, p_fecha_nacimiento date, p_agent_id uuid,
    p_ocupacion text DEFAULT null, p_ingresos_mensuales numeric DEFAULT null, p_polizas_externas text DEFAULT null,
    p_telefono2 text DEFAULT null, p_cedula text DEFAULT null, p_empresa text DEFAULT null
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_client_id bigint;
BEGIN
    UPDATE clients SET nombre = p_nombre, email = p_email, telefono1 = p_telefono1, telefono2 = p_telefono2, fecha_nacimiento = p_fecha_nacimiento, agent_id = p_agent_id, ocupacion = p_ocupacion, ingresos_mensuales = p_ingresos_mensuales, polizas_externas = p_polizas_externas, cedula = p_cedula, empresa = p_empresa, updated_at = NOW()
    WHERE id = p_id RETURNING id INTO v_client_id;
    RETURN (SELECT row_to_json(clients) FROM clients WHERE id = v_client_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_client_secure(p_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    DELETE FROM clients WHERE id = p_id;
END;
$$;

-- POLICIES
CREATE OR REPLACE FUNCTION get_policies_for_user()
RETURNS SETOF policies LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM policies WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() OR user_id = auth.uid() ORDER BY created_at DESC;
$$;

CREATE OR REPLACE FUNCTION create_policy_secure(
    p_client_id bigint, p_product_id bigint, p_prima_total numeric, p_fecha_emision date, p_fecha_vencimiento date, p_estatus_poliza text,
    p_agent_id uuid DEFAULT null, p_user_id uuid DEFAULT null, p_comision_agente numeric DEFAULT 0, p_productos_detalle jsonb DEFAULT '[]'::jsonb, p_suma_asegurada_total numeric DEFAULT 0
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_policy_id bigint;
BEGIN
    INSERT INTO policies (client_id, product_id, prima_total, fecha_emision, fecha_vencimiento, estatus_poliza, comision_agente, agent_id, user_id, productos_detalle, suma_asegurada_total, prima_mensual_total)
    VALUES (p_client_id, p_product_id, p_prima_total, p_fecha_emision, p_fecha_vencimiento, p_estatus_poliza::policy_status, p_comision_agente, p_agent_id, auth.uid(), p_productos_detalle, p_suma_asegurada_total, p_prima_total)
    RETURNING id INTO v_policy_id;
    RETURN (SELECT row_to_json(p) FROM policies p WHERE id = v_policy_id);
END;
$$;

CREATE OR REPLACE FUNCTION update_policy_secure(
    p_id bigint, p_client_id bigint, p_product_id bigint, p_prima_total numeric, p_fecha_emision date, p_fecha_vencimiento date, p_estatus_poliza text,
    p_agent_id uuid DEFAULT null, p_comision_agente numeric DEFAULT 0, p_productos_detalle jsonb DEFAULT '[]'::jsonb, p_suma_asegurada_total numeric DEFAULT 0
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_policy_id bigint;
BEGIN
    UPDATE policies SET client_id = p_client_id, product_id = p_product_id, prima_total = p_prima_total, fecha_emision = p_fecha_emision, fecha_vencimiento = p_fecha_vencimiento, estatus_poliza = p_estatus_poliza::policy_status, comision_agente = p_comision_agente, agent_id = p_agent_id, productos_detalle = p_productos_detalle, suma_asegurada_total = p_suma_asegurada_total, prima_mensual_total = p_prima_total, updated_at = NOW()
    WHERE id = p_id RETURNING id INTO v_policy_id;
    RETURN (SELECT row_to_json(p) FROM policies p WHERE id = v_policy_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_policy_secure(p_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    DELETE FROM policies WHERE id = p_id;
END;
$$;

CREATE OR REPLACE FUNCTION get_expiring_policies_for_user(days_in_future int)
RETURNS SETOF policies LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM policies
  WHERE 
    ((SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() OR user_id = auth.uid())
    AND fecha_vencimiento >= CURRENT_DATE 
    AND fecha_vencimiento <= (CURRENT_DATE + (days_in_future || ' days')::interval)
    AND estatus_poliza = 'ACTIVA'
  ORDER BY fecha_vencimiento ASC;
$$;

-- PRODUCTS
CREATE OR REPLACE FUNCTION get_products_for_user()
RETURNS SETOF products LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM products ORDER BY nombre ASC;
$$;

CREATE OR REPLACE FUNCTION create_product_secure(
    p_nombre text, p_categoria text, p_comision_porcentaje numeric, p_activo boolean, p_descripcion text,
    p_aseguradora text DEFAULT 'PALIG', p_prima_mensual numeric DEFAULT 0, p_suma_asegurada numeric DEFAULT 0
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_product_id bigint;
BEGIN
    INSERT INTO products (nombre, aseguradora, categoria, comision_porcentaje, prima_mensual, activo, descripcion, suma_asegurada, updated_at)
    VALUES (p_nombre, COALESCE(p_aseguradora, 'PALIG'), p_categoria, p_comision_porcentaje, p_prima_mensual, p_activo, p_descripcion, p_suma_asegurada, NOW())
    RETURNING id INTO v_product_id;
    RETURN (SELECT row_to_json(p) FROM products p WHERE id = v_product_id);
END;
$$;

CREATE OR REPLACE FUNCTION update_product_secure(
    p_id bigint, p_nombre text, p_categoria text, p_comision_porcentaje numeric, p_activo boolean, p_descripcion text,
    p_aseguradora text DEFAULT 'PALIG', p_prima_mensual numeric DEFAULT 0, p_suma_asegurada numeric DEFAULT 0
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_product_id bigint;
BEGIN
    UPDATE products SET nombre = p_nombre, aseguradora = COALESCE(p_aseguradora, 'PALIG'), categoria = p_categoria, comision_porcentaje = p_comision_porcentaje, prima_mensual = p_prima_mensual, activo = p_activo, descripcion = p_descripcion, suma_asegurada = p_suma_asegurada, updated_at = NOW()
    WHERE id = p_id RETURNING id INTO v_product_id;
    RETURN (SELECT row_to_json(p) FROM products p WHERE id = v_product_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_product_secure(p_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    DELETE FROM products WHERE id = p_id;
END;
$$;

-- TASKS
CREATE OR REPLACE FUNCTION get_tasks_for_user()
RETURNS SETOF tasks LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT * FROM tasks WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() OR user_id = auth.uid() ORDER BY fecha_vencimiento ASC;
$$;

CREATE OR REPLACE FUNCTION create_task_secure(
    p_descripcion text, p_tipo text, p_fecha_vencimiento date, p_prioridad text, p_estatus text,
    p_lead_id bigint DEFAULT null, p_client_id bigint DEFAULT null, p_agent_id uuid DEFAULT null, p_user_id uuid DEFAULT null
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_task_id bigint;
BEGIN
    INSERT INTO tasks (descripcion, tipo, fecha_vencimiento, prioridad, estatus, lead_id, client_id, agent_id, user_id)
    VALUES (p_descripcion, p_tipo, p_fecha_vencimiento, p_prioridad, p_estatus::task_status, p_lead_id, p_client_id, p_agent_id, auth.uid())
    RETURNING id INTO v_task_id;
    RETURN (SELECT row_to_json(t) FROM tasks t WHERE id = v_task_id);
END;
$$;

CREATE OR REPLACE FUNCTION update_task_secure(
    p_id bigint, p_descripcion text, p_tipo text, p_fecha_vencimiento date, p_prioridad text, p_estatus text,
    p_lead_id bigint DEFAULT null, p_client_id bigint DEFAULT null, p_agent_id uuid DEFAULT null
)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_task_id bigint;
BEGIN
    UPDATE tasks SET descripcion = p_descripcion, tipo = p_tipo, fecha_vencimiento = p_fecha_vencimiento, prioridad = p_prioridad, estatus = p_estatus::task_status, lead_id = p_lead_id, client_id = p_client_id, agent_id = p_agent_id, updated_at = NOW()
    WHERE id = p_id RETURNING id INTO v_task_id;
    RETURN (SELECT row_to_json(t) FROM tasks t WHERE id = v_task_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_task_secure(p_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    DELETE FROM tasks WHERE id = p_id;
END;
$$;

-- DASHBOARD
CREATE OR REPLACE FUNCTION get_dashboard_stats_for_user()
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_leads_count int;
    v_tasks_count int;
    v_policies_count int;
    v_commissions_total numeric;
BEGIN
    SELECT count(*) INTO v_leads_count FROM leads WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid();
    SELECT count(*) INTO v_tasks_count FROM tasks WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid() AND estatus != 'COMPLETADA';
    SELECT count(*) INTO v_policies_count FROM policies WHERE estatus_poliza = 'ACTIVA' AND ((SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid());
    SELECT COALESCE(sum(comision_agente), 0) INTO v_commissions_total FROM policies WHERE estatus_poliza = 'ACTIVA' AND ((SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid());
    
    RETURN json_build_object(
        'leads', v_leads_count,
        'tasks', v_tasks_count,
        'policies', v_policies_count,
        'commissions', v_commissions_total
    );
END;
$$;

CREATE OR REPLACE FUNCTION get_leads_by_status_for_user()
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_result json;
BEGIN
    SELECT json_object_agg(estatus_lead, count) INTO v_result
    FROM (
        SELECT estatus_lead, count(*) as count
        FROM leads
        WHERE (SELECT rol FROM profiles WHERE id = auth.uid()) = 'ADMIN' OR agent_id = auth.uid()
        GROUP BY estatus_lead
    ) t;
    RETURN v_result;
END;
$$;

-- GOALS
CREATE OR REPLACE FUNCTION get_monthly_goal(p_month int, p_year int)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_result json;
BEGIN
    SELECT row_to_json(g) INTO v_result FROM monthly_goals g WHERE g.user_id = auth.uid() AND g.month = p_month AND g.year = p_year;
    RETURN v_result;
END;
$$;

CREATE OR REPLACE FUNCTION upsert_monthly_goal(p_month int, p_year int, p_vida numeric, p_ap numeric, p_salud numeric)
RETURNS json LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE v_result json;
BEGIN
    INSERT INTO monthly_goals (user_id, month, year, vida, ap, salud) VALUES (auth.uid(), p_month, p_year, p_vida, p_ap, p_salud)
    ON CONFLICT (user_id, month, year) DO UPDATE SET vida = EXCLUDED.vida, ap = EXCLUDED.ap, salud = EXCLUDED.salud;
    SELECT row_to_json(g) INTO v_result FROM monthly_goals g WHERE g.user_id = auth.uid() AND g.month = p_month AND g.year = p_year;
    RETURN v_result;
END;
$$;


-- =============================================
-- 5. ALMACENAMIENTO (STORAGE BUCKETS)
-- =============================================

INSERT INTO storage.buckets (id, name, public) VALUES ('lead_files', 'lead_files', true) ON CONFLICT (id) DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('client_files', 'client_files', true) ON CONFLICT (id) DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('policy_files', 'policy_files', true) ON CONFLICT (id) DO NOTHING;

-- Políticas de Storage (Simplificadas para acceso total autenticado por bucket)
CREATE POLICY "Lead Files Access" ON storage.objects FOR ALL TO authenticated USING (bucket_id = 'lead_files') WITH CHECK (bucket_id = 'lead_files');
CREATE POLICY "Client Files Access" ON storage.objects FOR ALL TO authenticated USING (bucket_id = 'client_files') WITH CHECK (bucket_id = 'client_files');
CREATE POLICY "Policy Files Access" ON storage.objects FOR ALL TO authenticated USING (bucket_id = 'policy_files') WITH CHECK (bucket_id = 'policy_files');
